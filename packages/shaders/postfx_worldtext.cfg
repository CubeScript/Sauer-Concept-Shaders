// POSTFX Concept Shader to render a 2D text in the world.
// by @SalatielSauer

// "text" [width height] [x y z] [r g b a]
// example: _conceptshader_worldwrite "Hello, World!" [10 20] [512 512 525] [0.3 1 1 1]
_conceptshader_worldwrite = [
	local _loopchar
	_loopchar = [ loop $arg1 (strlen $arg2) [ $arg1 = (substr $arg2 $$arg1 1); arg3 ] ]

	_conceptshader_charcodes = []
	_conceptshader_charcodeslen = 0

	_loopchar c $arg1 [
		_conceptshader_charcodeslen = (+ $_conceptshader_charcodeslen 1)
		_conceptshader_charcodes = (concatword $_conceptshader_charcodes (strcode $c) (? (!= $_conceptshader_charcodeslen 0) ", " "") )   
	]
	
	_conceptshader_charcodes = (substr $_conceptshader_charcodes 0 (- (strlen $_conceptshader_charcodes) 2))
	_conceptshader_scaleW = (at $arg2 0)
	_conceptshader_scaleH = (at $arg2 1)
	_conceptshader_posX = (at $arg3 0)
	_conceptshader_posY = (at $arg3 1)
	_conceptshader_posZ = (at $arg3 2)
	_conceptshader_textR = (at $arg4 0)
	_conceptshader_textG = (at $arg4 1)
	_conceptshader_textB = (at $arg4 2)
	_conceptshader_textA = (at $arg4 3)

	_conceptshader_drawpostfx 0 0 $_conceptshader_scaleW $_conceptshader_scaleH
]

clearpostfx

_conceptshader_worldwrite (concatword "Hello, " (getname) "..") [10 20] [512 512 525] [0.3 1 1 1]
sleep 0 [
	_conceptshader_worldwrite "This is a PostFX Shader! :)" [10 20] [505 512 512] [1 0.2 1 1]
]

_conceptshader_drawpostfx = [
	shader 0 [conceptshader_worldtext@getmillis] [
		// --- Vertex Shader ---
		attribute vec4 vvertex;
		@(screentexcoord 0)
		varying vec2 texcoord0;
		
		void main(void) {
			gl_Position = vvertex;
			texcoord0 = vtexcoord0;
		}
	] [
		// --- Fragment Shader ---
		uniform sampler2D tex0;
		varying vec2 texcoord0;
		//uniform vec4 params;

		uniform mat4 camprojmatrix;
		uniform vec4 camera;
		
		// --- Text Placement Parameters ---
		// the text is drawn on a vertical plane with its bottom–left at (512*2,512*2,512*2) by default.
		// characters are laid out along +X and extend upward along +Z.
		uniform vec3 textPosition = vec3(@(_conceptshader_posX)*2.0, @(_conceptshader_posY)*2.0, @(_conceptshader_posZ)*2.0);
		// each character’s size in world units (width along X, height along Z).
		uniform vec2 textCharSize = vec2(@(_conceptshader_scaleW), @(_conceptshader_scaleH))	;
		
		// --- Text Colors ---
		uniform vec4 textColor = vec4(@(_conceptshader_textR), @(_conceptshader_textG), @(_conceptshader_textB), @(_conceptshader_textA));
		
		// --- Text Data ---
		const int textLength = @(_conceptshader_charcodeslen);
		uniform int textChars[textLength] = int[textLength](
			@(result $_conceptshader_charcodes)
		);
		
		// 8x8 Bitmap Font for ASCII 32 (' ') through 122 ('z')
		// each character is 8 rows (8-bit per row).
		const int font[832] = {
				// ASCII 32: ' '
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				// ASCII 33: '!'
				0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
				// ASCII 34: '"'
				0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00,
				// ASCII 35: '#'
				0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00,
				// ASCII 36: '$'
				0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00,
				// ASCII 37: '%'
				0x00,0x63,0x64,0x08,0x10,0x26,0x46,0x00,
				// ASCII 38: '&'
				0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00,
				// ASCII 39: '''
				0x18,0x18,0x10,0x00,0x00,0x00,0x00,0x00,
				// ASCII 40: '('
				0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,
				// ASCII 41: ')'
				0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,
				// ASCII 42: '*'
				0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,
				// ASCII 43: '+'
				0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,
				// ASCII 44: ','
				0x00,0x00,0x00,0x00,0x18,0x18,0x10,0x00,
				// ASCII 45: '-'
				0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
				// ASCII 46: '.'
				0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,
				// ASCII 47: '/'
				0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,
				// ASCII 48: '0'
				0x3C,0x66,0x6E,0x7E,0x76,0x66,0x3C,0x00,
				// ASCII 49: '1'
				0x18,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,
				// ASCII 50: '2'
				0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00,
				// ASCII 51: '3'
				0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,
				// ASCII 52: '4'
				0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00,
				// ASCII 53: '5'
				0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,
				// ASCII 54: '6'
				0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,
				// ASCII 55: '7'
				0x7E,0x66,0x0C,0x18,0x18,0x18,0x18,0x00,
				// ASCII 56: '8'
				0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,
				// ASCII 57: '9'
				0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,
				// ASCII 58: ':'
				0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,
				// ASCII 59: ';'
				0x00,0x18,0x18,0x00,0x00,0x18,0x10,0x00,
				// ASCII 60: '<'
				0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,
				// ASCII 61: '='
				0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,0x00,
				// ASCII 62: '>'
				0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,
				// ASCII 63: '?'
				0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00,
				// ASCII 64: '@'
				0x3C,0x66,0x6E,0x6E,0x6E,0x60,0x3C,0x00,
				// ASCII 65: 'A'
				0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00,
				// ASCII 66: 'B'
				0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00,
				// ASCII 67: 'C'
				0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,
				// ASCII 68: 'D'
				0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00,
				// ASCII 69: 'E'
				0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00,
				// ASCII 70: 'F'
				0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00,
				// ASCII 71: 'G'
				0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00,
				// ASCII 72: 'H'
				0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
				// ASCII 73: 'I'
				0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
				// ASCII 74: 'J'
				0x1E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00,
				// ASCII 75: 'K'
				0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,
				// ASCII 76: 'L'
				0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,
				// ASCII 77: 'M'
				0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00,
				// ASCII 78: 'N'
				0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00,
				// ASCII 79: 'O'
				0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
				// ASCII 80: 'P'
				0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,
				// ASCII 81: 'Q'
				0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00,
				// ASCII 82: 'R'
				0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00,
				// ASCII 83: 'S'
				0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00,
				// ASCII 84: 'T'
				0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00,
				// ASCII 85: 'U'
				0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
				// ASCII 86: 'V'
				0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,
				// ASCII 87: 'W'
				0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,
				// ASCII 88: 'X'
				0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,
				// ASCII 89: 'Y'
				0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00,
				// ASCII 90: 'Z'
				0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,
				// ASCII 91: '['
				0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00,
				// ASCII 92: '\'
				0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00,
				// ASCII 93: ']'
				0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,
				// ASCII 94: '^'
				0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,
				// ASCII 95: '_'
				0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,
				// ASCII 96: '`'
				0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,
				// ASCII 97: 'a'
				0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00,
				// ASCII 98: 'b'
				0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,
				// ASCII 99: 'c'
				0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00,
				// ASCII 100: 'd'
				0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,
				// ASCII 101: 'e'
				0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00,
				// ASCII 102: 'f'
				0x0E,0x18,0x3E,0x18,0x18,0x18,0x18,0x00,
				// ASCII 103: 'g'
				0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C,
				// ASCII 104: 'h'
				0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00,
				// ASCII 105: 'i'
				0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,
				// ASCII 106: 'j'
				0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x3C,
				// ASCII 107: 'k'
				0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00,
				// ASCII 108: 'l'
				0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
				// ASCII 109: 'm'
				0x00,0x00,0x7E,0x6B,0x6B,0x63,0x63,0x00,
				// ASCII 110: 'n'
				0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
				// ASCII 111: 'o'
				0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
				// ASCII 112: 'p'
				0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
				// ASCII 113: 'q'
				0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
				// ASCII 114: 'r'
				0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00,
				// ASCII 115: 's'
				0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,
				// ASCII 116: 't'
				0x18,0x18,0x7E,0x18,0x18,0x18,0x0E,0x00,
				// ASCII 117: 'u'
				0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
				// ASCII 118: 'v'
				0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
				// ASCII 119: 'w'
				0x00,0x00,0x63,0x63,0x6B,0x7F,0x36,0x00,
				// ASCII 120: 'x'
				0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,
				// ASCII 121: 'y'
				0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C,
				// ASCII 122: 'z'
				0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00,
				// ASCII 110: 'n'
				0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
				// ASCII 111: 'o'
				0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
				// ASCII 112: 'p'
				0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
				// ASCII 113: 'q'
				0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
				// ASCII 114: 'r'
				0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00,
				// ASCII 115: 's'
				0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,
				// ASCII 116: 't'
				0x18,0x18,0x7E,0x18,0x18,0x18,0x0E,0x00,
				// ASCII 117: 'u'
				0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
				// ASCII 118: 'v'
				0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
				// ASCII 119: 'w'
				0x00,0x00,0x63,0x63,0x6B,0x7F,0x36,0x00,
				// ASCII 120: 'x'
				0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,
				// ASCII 121: 'y'
				0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C,
				// ASCII 122: 'z'
				0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00
		};

		// returns true if, in the 8×8 grid, the given pixel (col, row) is “on” for the character.
		bool getFontPixel(int charIndex, ivec2 pixel) {
			if (charIndex < 0 || charIndex >= 104 || pixel.x < 0 || pixel.x >= 8 || pixel.y < 0 || pixel.y >= 8) return false;
			
			int fontIndex = charIndex * 8 + pixel.y;
			int row = font[fontIndex];
			return (row & (1 << (7 - pixel.x))) != 0;
		}
		
		// projects a world-space point to screen-space
		vec2 projectToScreen(vec3 worldPos, mat4 projMatrix, out bool inFront) {
			vec4 clipSpacePos = projMatrix * vec4(worldPos - camera.xyz, 1.0);
			if (clipSpacePos.w > 0.0) {
				vec3 ndc = clipSpacePos.xyz / clipSpacePos.w;
				inFront = true;
				return ndc.xy;
			}
			inFront = false;
			return vec2(-1.0);
		}
		
		// determines whether point P lies inside the projected quadrilateral defined by A, B, C, and D.
		bool pointInQuad(vec2 P, vec2 A, vec2 B, vec2 C, vec2 D) {
			float cross1 = (B.x - A.x) * (P.y - A.y) - (B.y - A.y) * (P.x - A.x);
			float cross2 = (C.x - B.x) * (P.y - B.y) - (C.y - B.y) * (P.x - B.x);
			float cross3 = (D.x - C.x) * (P.y - C.y) - (D.y - C.y) * (P.x - C.x);
			float cross4 = (A.x - D.x) * (P.y - D.y) - (A.y - D.y) * (P.x - D.x);
			bool allPos = (cross1 >= 0.0) && (cross2 >= 0.0) && (cross3 >= 0.0) && (cross4 >= 0.0);
			bool allNeg = (cross1 <= 0.0) && (cross2 <= 0.0) && (cross3 <= 0.0) && (cross4 <= 0.0);
			return allPos || allNeg;
		}
		
		// optimized face test: projects the quad's corners, does a quick bounding box check,
		// then performs the full point-in-quad test.
		bool checkFace(vec3 A, vec3 B, vec3 C, vec3 D, vec2 screenPos) {
			bool inA, inB, inC, inD;
			vec2 sA = projectToScreen(A, camprojmatrix, inA);
			vec2 sB = projectToScreen(B, camprojmatrix, inB);
			vec2 sC = projectToScreen(C, camprojmatrix, inC);
			vec2 sD = projectToScreen(D, camprojmatrix, inD);
			if (!(inA && inB && inC && inD)) return false;
			
			vec2 minScreen = min(min(sA, sB), min(sC, sD));
			vec2 maxScreen = max(max(sA, sB), max(sC, sD));
			if (screenPos.x < minScreen.x || screenPos.x > maxScreen.x || screenPos.y < minScreen.y || screenPos.y > maxScreen.y) return false;
			
			return pointInQuad(screenPos, sA, sB, sC, sD);
		}
		
		void main(void) {
			vec4 original = texture2D(tex0, texcoord0);
			vec2 screenPos = texcoord0 * 2.0 - 1.0;
			//vec3 textPosition = vec3((512*2)+(params.x*100), (512*2)+(params.y*100), 512*2);
			//vec2 textCharSize = vec2(params.z*100, params.w*100);

			// --- Global Bounding Box Test ---
			// compute the overall text plane bounds so that we can exit early if this fragment is not nearby.
			float totalWidth = float(textLength) * textCharSize.x;
			vec3 globalBL = textPosition;
			vec3 globalBR = textPosition + vec3(totalWidth, 0.0, 0.0);
			vec3 globalTL = textPosition + vec3(0.0, 0.0, textCharSize.y);
			vec3 globalTR = textPosition + vec3(totalWidth, 0.0, textCharSize.y);
			bool in1, in2, in3, in4;
			vec2 gsBL = projectToScreen(globalBL, camprojmatrix, in1);
			vec2 gsBR = projectToScreen(globalBR, camprojmatrix, in2);
			vec2 gsTR = projectToScreen(globalTR, camprojmatrix, in3);
			vec2 gsTL = projectToScreen(globalTL, camprojmatrix, in4);
			if (!(in1 && in2 && in3 && in4)) {
				gl_FragColor = original;
				return;
			}

			vec2 globalMin = min(min(gsBL, gsBR), min(gsTL, gsTR));
			vec2 globalMax = max(max(gsBL, gsBR), max(gsTL, gsTR));
			if (screenPos.x < globalMin.x || screenPos.x > globalMax.x ||
				screenPos.y < globalMin.y || screenPos.y > globalMax.y) {
				gl_FragColor = original;
				return;
			}
			
			// --- Main Per-Pixel Loop ---
			vec4 finalColor = original;
			bool hit = false;
			
			// precompute pixel size for the 8×8 grid.
			float pixelWidth = textCharSize.x / 8.0;
			float pixelHeight = textCharSize.y / 8.0;
			
			// loop over each character.
			for (int i = 0; i < textLength; i++) {
				int ascii = textChars[i] - 32;
				vec3 charOrigin = textPosition + vec3(float(i) * textCharSize.x, 0.0, 0.0);
				
				// loop over rows and columns in the 8×8 grid.
				for (int row = 0; row < 8; row++) {
					for (int col = 0; col < 8; col++) {
						// font data is arranged with row 0 at the top; we flip the row index so that row 0 is at the bottom.
						if (getFontPixel(ascii, ivec2(col, 7 - row))) {
							vec3 offset = vec3(float(col) * pixelWidth, 0.0, float(row) * pixelHeight);
							vec3 P = charOrigin + offset;
							vec3 Q = P + vec3(pixelWidth, 0.0, 0.0);
							vec3 S = P + vec3(0.0, 0.0, pixelHeight);
							vec3 R = Q + vec3(0.0, 0.0, pixelHeight);
							
							if (checkFace(P, Q, R, S, screenPos)) {
							finalColor = mix(original, textColor, textColor.a);
							hit = true;
							break;
							}
						}
					}
					if (hit) break;
				}
				if (hit) break;
			}
			
			gl_FragColor = finalColor;
		}
	]

	addpostfx [conceptshader_worldtext@getmillis]
]
