// POSTFX Concept Shader to render a 2D text on screen.
// by @SalatielSauer

// "text" [width height] [x y] [text rgba] [background rgba]
// example: _conceptshader_screenwrite "Hello, World!" [0.04 0.02] [0.37 0.5] [1 0 1 1] [0 0 0 0.5]
_conceptshader_screenwrite = [
	local _loopchar
	_loopchar = [ loop $arg1 (strlen $arg2) [ $arg1 = (substr $arg2 $$arg1 1); arg3 ] ]

	_conceptshader_charcodes = []
	_conceptshader_charcodeslen = 0

	_loopchar c $arg1 [
		_conceptshader_charcodeslen = (+ $_conceptshader_charcodeslen 1)
		_conceptshader_charcodes = (concatword $_conceptshader_charcodes (strcode $c) (? (!= $_conceptshader_charcodeslen 0) ", " "") )   
	]

	_conceptshader_charcodes = (substr $_conceptshader_charcodes 0 (- (strlen $_conceptshader_charcodes) 2))
	_conceptshader_scaleW = (at $arg2 0)
	_conceptshader_scaleH = (at $arg2 1)
	_conceptshader_charposX = (at $arg3 0)
	_conceptshader_charposY = (at $arg3 1)
	_conceptshader_textR = (at $arg4 0)
	_conceptshader_textG = (at $arg4 1)
	_conceptshader_textB = (at $arg4 2)
	_conceptshader_textA = (at $arg4 3)
	_conceptshader_backR = (at $arg5 0)
	_conceptshader_backG = (at $arg5 1)
	_conceptshader_backB = (at $arg5 2)
	_conceptshader_backA = (at $arg5 3)

	//echo $_conceptshader_charcodes
	_conceptshader_drawpostfx $_conceptshader_charposX $_conceptshader_charposY $_conceptshader_scaleH $_conceptshader_scaleW
]

_conceptshader_drawpostfx = [
	shader 0 [conceptshader_screentext@getmillis] [
		// --- Vertex Shader ---
		attribute vec4 vvertex;
		@(screentexcoord 0)
		varying vec2 texcoord0;
		
		void main(void) {
			gl_Position = vvertex;
			texcoord0 = vtexcoord0;
		}
	] [
		// --- Fragment Shader ---
		uniform sampler2D tex0;
		uniform vec4 params;
		varying vec2 texcoord0;
		varying vec4 color;

		// --- Text Placement Parameters ---
		uniform vec2 textPosition = vec2(0, 0); 	 // bottom-left position on screen
		uniform vec2 textScale 	= vec2(0.01, 0.02); // size of each character (width, height)
		uniform vec4 textColor  = vec4(@(_conceptshader_textR), @(_conceptshader_textG), @(_conceptshader_textB), @(_conceptshader_textA));
		uniform vec4 bgColor    = vec4(@(_conceptshader_backR), @(_conceptshader_backG), @(_conceptshader_backB), @(_conceptshader_backA));
		const int textLength 		= @(_conceptshader_charcodeslen);

		uniform int textChars[textLength] = int[textLength](
			@(result $_conceptshader_charcodes)
		);

		// 8x8 Bitmap Font for ASCII 32 (' ') through 122 ('z')
		// each character is 8 rows (8-bit per row).
		const int font[832] = {
			// ASCII 32: ' '
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			// ASCII 33: '!'
			0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
			// ASCII 34: '"'
			0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00,
			// ASCII 35: '#'
			0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00,
			// ASCII 36: '$'
			0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00,
			// ASCII 37: '%'
			0x00,0x63,0x64,0x08,0x10,0x26,0x46,0x00,
			// ASCII 38: '&'
			0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00,
			// ASCII 39: '''
			0x18,0x18,0x10,0x00,0x00,0x00,0x00,0x00,
			// ASCII 40: '('
			0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,
			// ASCII 41: ')'
			0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,
			// ASCII 42: '*'
			0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,
			// ASCII 43: '+'
			0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,
			// ASCII 44: ','
			0x00,0x00,0x00,0x00,0x18,0x18,0x10,0x00,
			// ASCII 45: '-'
			0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
			// ASCII 46: '.'
			0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,
			// ASCII 47: '/'
			0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,
			// ASCII 48: '0'
			0x3C,0x66,0x6E,0x7E,0x76,0x66,0x3C,0x00,
			// ASCII 49: '1'
			0x18,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,
			// ASCII 50: '2'
			0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00,
			// ASCII 51: '3'
			0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,
			// ASCII 52: '4'
			0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00,
			// ASCII 53: '5'
			0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,
			// ASCII 54: '6'
			0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,
			// ASCII 55: '7'
			0x7E,0x66,0x0C,0x18,0x18,0x18,0x18,0x00,
			// ASCII 56: '8'
			0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,
			// ASCII 57: '9'
			0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,
			// ASCII 58: ':'
			0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,
			// ASCII 59: ';'
			0x00,0x18,0x18,0x00,0x00,0x18,0x10,0x00,
			// ASCII 60: '<'
			0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,
			// ASCII 61: '='
			0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,0x00,
			// ASCII 62: '>'
			0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,
			// ASCII 63: '?'
			0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00,
			// ASCII 64: '@'
			0x3C,0x66,0x6E,0x6E,0x6E,0x60,0x3C,0x00,
			// ASCII 65: 'A'
			0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00,
			// ASCII 66: 'B'
			0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00,
			// ASCII 67: 'C'
			0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,
			// ASCII 68: 'D'
			0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00,
			// ASCII 69: 'E'
			0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00,
			// ASCII 70: 'F'
			0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00,
			// ASCII 71: 'G'
			0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00,
			// ASCII 72: 'H'
			0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
			// ASCII 73: 'I'
			0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
			// ASCII 74: 'J'
			0x1E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00,
			// ASCII 75: 'K'
			0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,
			// ASCII 76: 'L'
			0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,
			// ASCII 77: 'M'
			0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00,
			// ASCII 78: 'N'
			0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00,
			// ASCII 79: 'O'
			0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
			// ASCII 80: 'P'
			0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,
			// ASCII 81: 'Q'
			0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00,
			// ASCII 82: 'R'
			0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00,
			// ASCII 83: 'S'
			0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00,
			// ASCII 84: 'T'
			0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00,
			// ASCII 85: 'U'
			0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
			// ASCII 86: 'V'
			0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,
			// ASCII 87: 'W'
			0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,
			// ASCII 88: 'X'
			0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,
			// ASCII 89: 'Y'
			0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00,
			// ASCII 90: 'Z'
			0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,
			// ASCII 91: '['
			0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00,
			// ASCII 92: '\'
			0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00,
			// ASCII 93: ']'
			0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,
			// ASCII 94: '^'
			0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,
			// ASCII 95: '_'
			0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,
			// ASCII 96: '`'
			0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,
			// ASCII 97: 'a'
			0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00,
			// ASCII 98: 'b'
			0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,
			// ASCII 99: 'c'
			0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00,
			// ASCII 100: 'd'
			0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,
			// ASCII 101: 'e'
			0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00,
			// ASCII 102: 'f'
			0x0E,0x18,0x3E,0x18,0x18,0x18,0x18,0x00,
			// ASCII 103: 'g'
			0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C,
			// ASCII 104: 'h'
			0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00,
			// ASCII 105: 'i'
			0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,
			// ASCII 106: 'j'
			0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x3C,
			// ASCII 107: 'k'
			0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00,
			// ASCII 108: 'l'
			0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
			// ASCII 109: 'm'
			0x00,0x00,0x7E,0x6B,0x6B,0x63,0x63,0x00,
			// ASCII 110: 'n'
			0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
			// ASCII 111: 'o'
			0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
			// ASCII 112: 'p'
			0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
			// ASCII 113: 'q'
			0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
			// ASCII 114: 'r'
			0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00,
			// ASCII 115: 's'
			0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,
			// ASCII 116: 't'
			0x18,0x18,0x7E,0x18,0x18,0x18,0x0E,0x00,
			// ASCII 117: 'u'
			0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
			// ASCII 118: 'v'
			0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
			// ASCII 119: 'w'
			0x00,0x00,0x63,0x63,0x6B,0x7F,0x36,0x00,
			// ASCII 120: 'x'
			0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,
			// ASCII 121: 'y'
			0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C,
			// ASCII 122: 'z'
			0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00,
			// ASCII 110: 'n'
			0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
			// ASCII 111: 'o'
			0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
			// ASCII 112: 'p'
			0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
			// ASCII 113: 'q'
			0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
			// ASCII 114: 'r'
			0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00,
			// ASCII 115: 's'
			0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,
			// ASCII 116: 't'
			0x18,0x18,0x7E,0x18,0x18,0x18,0x0E,0x00,
			// ASCII 117: 'u'
			0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
			// ASCII 118: 'v'
			0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
			// ASCII 119: 'w'
			0x00,0x00,0x63,0x63,0x6B,0x7F,0x36,0x00,
			// ASCII 120: 'x'
			0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,
			// ASCII 121: 'y'
			0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C,
			// ASCII 122: 'z'
			0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00
		};

		bool getFontPixel(int charIndex, ivec2 pixel) {
			// make sure charIndex is within our font range (0..58)
			if (charIndex < 0 || charIndex >= 104 || pixel.x < 0 || pixel.x >= 8 || pixel.y < 0 || pixel.y >= 8)
				return false;
			
			int fontIndex = charIndex * 8 + pixel.y;
			int row = font[fontIndex];
			// check if the bit at position (7 - pixel.x) is set
			return (row & (1 << (7 - pixel.x))) != 0;
		}

		void main(void) {
			vec2 textPosition = vec2(params.x, params.y);
			vec2 textScale = vec2(params.z, params.w);
			// get the original screen pixel color.
			vec4 original = texture2D(tex0, texcoord0);
			vec2 pos = texcoord0;
			// compute position relative to the textâ€™s bottom-left
			vec2 textArea = pos - textPosition;
			
			// if the current fragment is within the text region...
			if (textArea.x >= 0.0 && textArea.y >= 0.0 && textArea.x < textScale.x * float(textLength) && textArea.y < textScale.y) {
					
				// determine which character of the text we are in.
				int charIndex = int(textArea.x / textScale.x);
				charIndex = clamp(charIndex, 0, textLength - 1);
				
				// retrieve the ASCII code (subtract 32 so that space = index 0)
				int ascii = textChars[charIndex] - 32;
				
				// determine which pixel inside the 8x8 grid (note the vertical flip)
				ivec2 pixel = ivec2(
					int(fract(textArea.x / textScale.x) * 8.0),
					7 - int((textArea.y / textScale.y) * 8.0)
				);
				
				// if this bit is "on" in our font, output the text color;
				// otherwise use the background color.
				if (getFontPixel(ascii, pixel)) {
					gl_FragColor = textColor;
				} else {
					gl_FragColor = mix(original, bgColor, bgColor.a);
				}

			} else {
				// outside the text area: keep the original screen intact.
				gl_FragColor = original;
			}
		}

	]

	//clearpostfx
	setpostfx [conceptshader_screentext@getmillis] $arg1 $arg2 $arg3 $arg4
]

_conceptshader_screentext_gui_tab = 0;
_conceptshader_screentext_gui_input = "";
_conceptshader_screentext_gui_WH = "0.04 0.02"
_conceptshader_screentext_gui_XY = "0.37 0.8"
_conceptshader_screentext_gui_RGBA = "1 0 1 1"
_conceptshader_screentext_gui_BKRGBA = "0 0 0 0.5"

newgui screentexttest [
	if (!=s $textshow "") [ _conceptshader_screentext_gui_update ]
	guialign 0 [
		guieditor _conceptshader_screentext_gui_input -30 5
	]
	guialign 0 [
		loop i 2 [
			guistayopen [
				guibutton (_strstatecolor (= $_conceptshader_screentext_gui_tab $i) (at ["transform" "colors"] $i)) [
					_conceptshader_screentext_gui_tab = @i
				] 0
				guibar
			]
		]
	]
	if (= $_conceptshader_screentext_gui_tab 0) [
		guialign -1 [
			guititle "^f0W^f1H^f7:^t"
			guifield _conceptshader_screentext_gui_WH 15
		]
		guialign -1 [
			guititle "^f2X^f3Y^f7:^t"
			guifield _conceptshader_screentext_gui_XY 15
		]
	]
	if (= $_conceptshader_screentext_gui_tab 1) [
		guialign -1 [
			guititle "^f3R^f0G^f1B^f4A^f7: "
			guifield _conceptshader_screentext_gui_RGBA 15
			guitext "^f4(text)" 0
		]
		guialign -1 [
			guititle "^f3R^f0G^f1B^f4A^f7: "
			guifield _conceptshader_screentext_gui_BKRGBA 15
			guitext "^f4(back)" 0
		]
	]
] 0

_conceptshader_screentext_gui_update = [
	_conceptshader_screenwrite $textshow $_conceptshader_screentext_gui_WH $_conceptshader_screentext_gui_XY $_conceptshader_screentext_gui_RGBA $_conceptshader_screentext_gui_BKRGBA
]

showgui screentexttest

_strstatecolor = [
	if (=s $arg3 "") [arg3 = "4"]; if (=s $arg4 "") [arg4 = "0"]
	result (concatword "^f" (at [@arg3 @arg4] $arg1) $arg2)
]
